# Execution Environment

## Introduction

This project serves as an introduction to Compilers. To properly understand what needs to be done, it is important to grasp the concept of a real execution environment, which will be further explored in the "Languages and Compilers" course. We suggest reviewing the proposal for the [C-- Compiler](https://github.com/PCS3616/projeto-compilador) before diving into this project.

## Compiler Foundation

The execution environment is a feature usually integrated into the compiler that provides methods and resources to execute the object code generated by the compiler. It manages memory and instructions to execute the generated code. The standard structure of the execution memory (different from machine memory) is as follows:

  | Section        | Description                                                                                      |
  |----------------|--------------------------------------------------------------------------------------------------|
  | Code           | Contains the compiled object code, allocated statically.                                         |
  | Static         | Holds variables and parameters generated by the compiler, allocated statically.                  |
  | Heap           | Stores long-duration variables during execution (spanning multiple procedures), allocated dynamically, growing towards higher addresses. |
  | Free Memory    | Can be occupied by either the heap or the stack.                                                 |
  | Stack          | Temporarily stores heap values during procedure calls to be restored later, allocated dynamically, growing towards lower addresses. |

The execution environment runs the compiled code line by line, storing used variables in value tables. When a subroutine is called, a new procedure is created, and all variables from the current state are pushed onto the stack as an activation record. The call and return sequences manage the pushing and popping of activation records onto and off the stack. The heap stores values that need to persist across multiple procedures.

An activation record must contain essential values for resuming execution later, such as variables and their values, the return point, and other useful information, all structured clearly and consistently. The call and return sequences handle these values properly to push or pop the records and modify the code as needed.

In addition to these organizational functions, the execution environment ensures that all functions used by the compiler to generate code are properly implemented, such as:
- Arithmetic operations involving types larger than the system's basic unit.
- Proper handling of input and output operations.

## The Task

The goal is to develop an execution environment for the [C-- Compiler](https://github.com/PCS3616/projeto-compilador). The execution environment should be structured as explained in the previous section. The compiled code will be placed in a file named `code.asm`, and your execution environment must correctly execute this code after compilation.

The project can be completed individually or in pairs. Defining the scope, handling error messages coherently, addressing potential limitations, and implementing features beyond those described above are also part of the task.

### Challenge

A highly useful tool for programmers (and briefly explored in the first laboratory) is the _debugger_. A debugger provides various functionalities, including the insertion of _breakpoints_, allowing programmers to pause the code execution at specific points and inspect variables at that moment. Your challenge is to enable users of your execution environment to insert a _breakpoint_ at any label in the code. Whenever execution reaches that label, the program should pause and wait for a user command to resume.

## Questions

Here are some questions to answer after coding the environment:

1. Can memory usage be made more efficient? How? If yes, why was the less efficient approach chosen?
2. Can the written code be more efficient? How? If yes, why was the less efficient approach chosen?
3. What was the greatest difficulty in implementing the execution environment?
4. What are the recommended limits for C-- code to avoid execution issues?

## Deliverables

You must submit two or more files:

1. **Environment**: A file in MVN format named `ambiente.asm` containing the code for your execution environment.
2. **Report**: A file named `relatorio_<NUSP1>_<NUSP2>.pdf` for projects completed in pairs, or `relatorio_<NUSP>.pdf` for individual projects. This report should include:
   - A summarized problem description and related concepts.
   - A detailed description of the solution steps, the strategy used in each module, and other relevant information.
   - Test execution screenshots, if applicable.
3. Any other files you find necessary.
